syntax = "proto3";
package stegos.blockchain;

import "crypto.proto";
import "view_changes.proto";

message PaymentOutput {
    stegos.crypto.PublicKey recipient = 1;
    stegos.crypto.Pt cloaking_hint = 2;
    stegos.crypto.BulletProof proof = 3;
    stegos.crypto.EncryptedPayload payload = 4;
    uint64 locked_timestamp = 5;
}

message PublicPaymentOutput {
    stegos.crypto.PublicKey recipient = 1;
    int64 serno = 2;
    int64 amount = 3;
    uint64 locked_timestamp = 4;
}

message StakeOutput {
    stegos.crypto.PublicKey recipient = 1;
    stegos.crypto.SecurePublicKey validator = 2;
    int64 amount = 3;
    int64 serno = 4;
    stegos.crypto.SecureSignature signature = 5;
}

message Output {
    oneof output {
        PaymentOutput payment_output = 1;
        PublicPaymentOutput public_payment_output = 2;
        StakeOutput stake_output = 3;
    }
}

message SlashingTransaction {
    SlashingProof proof = 1;
    repeated stegos.crypto.Hash txins = 2;
    repeated Output txouts = 3;
}

message ServiceAwardTransaction {
    repeated Output winner_reward = 1;
}

message CoinbaseTransaction {
    int64 block_reward = 1;
    int64 block_fee = 2;
    stegos.crypto.Fr gamma = 3;
    repeated Output txouts = 4;
}

message PaymentTransaction {
    repeated stegos.crypto.Hash txins = 1;
    repeated Output txouts = 2;
    stegos.crypto.Fr gamma = 3;
    int64 fee = 4;
    stegos.crypto.SchnorrSig sig = 5;
}

message RestakeTransaction {
    repeated stegos.crypto.Hash txins = 1;
    repeated Output txouts = 2;
    stegos.crypto.SecureSignature signature = 3;
}

message Transaction {
    oneof transaction {
        CoinbaseTransaction coinbase_transaction = 1;
        PaymentTransaction payment_transaction = 2;
        RestakeTransaction restake_transaction = 3;
        SlashingTransaction slashing_transaction = 4;
        ServiceAwardTransaction service_reward_transaction = 5;
    }
}

message MacroBlockHeader {
    uint64 version = 1;
    stegos.crypto.Hash previous = 2;
    uint64 epoch = 3;
    uint32 view_change = 4;
    stegos.crypto.SecurePublicKey pkey = 5;
    stegos.crypto.VRF random = 6;
    uint64 difficulty = 15;
    uint64 timestamp = 7;
    int64 block_reward = 8;
    repeated bool activity_map = 9;
    stegos.crypto.Fr gamma = 10;
    stegos.crypto.Hash inputs_range_hash = 11;
    uint32 inputs_len = 12;
    stegos.crypto.Hash outputs_range_hash = 13;
    uint32 outputs_len = 14;
}

message MacroBlock {
    MacroBlockHeader header = 1;
    stegos.crypto.SecureSignature multisig = 2;
    repeated bool multisigmap = 3;
    repeated stegos.crypto.Hash inputs = 4;
    repeated Output outputs = 5;
}

message MicroBlockHeader {
    uint64 version = 1;
    stegos.crypto.Hash previous = 2;
    uint64 epoch = 3;
    uint32 offset = 4;
    uint32 view_change = 5;
    ViewChangeProof view_change_proof = 6;
    stegos.crypto.SecurePublicKey pkey = 7;
    stegos.crypto.VRF random = 8;
    bytes solution = 11;
    uint64 timestamp = 9;
    stegos.crypto.Hash transactions_range_hash = 10;
}

message MicroBlock {
    MicroBlockHeader header = 1;
    stegos.crypto.SecureSignature sig = 2;
    repeated Transaction transactions = 3;
}

message Block {
    oneof block {
        MacroBlock macro_block = 1;
        MicroBlock micro_block = 2;
    }
}

message SlashingProof {
    MicroBlock block1 = 1;
    MicroBlock block2 = 2;
}